# 2024 PNU SW스터디그룹 20조

- **202155528 김민찬**
- **202155597 임도균**
- **202155600 전동훈**
- **202155584 이영민**

---

## 목차

1. [스터디 배경 및 주제](#스터디-배경-및-주제)
   - 1.1 [스터디 배경](#11-스터디-배경)
   - 1.2 [스터디 주제](#12-스터디-주제)
2. [스터디 목표 및 방식](#스터디-목표-및-방식)
   - 2.1 [스터디 목표](#21-스터디-목표)
   - 2.2 [스터디 방식](#22-스터디-방식)
3. [스터디 내용](#스터디-내용)
   - 3.1 [김민찬: 네트워크](#31-김민찬-네트워크)
   - 3.2 [임도균: AI 알고리즘](#32-임도균-ai-알고리즘)
   - 3.3 [전동훈: 알고리즘](#33-전동훈-알고리즘)
   - 3.4 [이영민: iOS 앱 개발 (SwiftUI)](#34-이영민-ios-앱-개발-swiftui)
4. [스터디 진행 결과](#스터디-진행-결과)
5. [향후 계획](#향후-계획)

---

## 스터디 배경 및 주제

### 1.1 스터디 배경
공모전 탈락으로 인해 기존의 특정 프로젝트 기반의 스터디 진행은 중단되었으나, 이를 새로운 학습 기회로 전환하고자 합니다. 각자 관심 있는 주제를 자유롭게 학습하고 발표하며, 팀원 간 지식 공유를 통해 스터디의 목표를 재정립하였습니다.

### 1.2 스터디 주제
각 팀원이 관심 있는 분야에서 주제를 선정하여 학습을 진행합니다. 선정 주제는 **알고리즘, 네트워크, AI, iOS 개발** 등 다양한 주제를 포괄하며, 발표를 통해 상호 이해도를 높이고자 합니다.

---

## 스터디 목표 및 방식

### 2.1 스터디 목표
- 각자 관심 있는 주제를 자율적으로 학습하여 다른 팀원들에게 발표 및 피드백 과정을 통해 새로운 관점과 지식을 습득하고자 합니다.

### 2.2 스터디 방식
1. **주제 선정**
   - 알고리즘, 어플리케이션 개발, 데이터 분석, AI 등 각자의 관심사에 따라 자유롭게 주제를 선정합니다.
2. **학습 활동**
   - 선정한 주제를 학습하고, 학습 내용을 정리하여 깃허브에 업로드합니다.
3. **발표 및 공유**
   - 매주 금요일 오전 11시에 학습 내용을 공유합니다.
4. **질의응답과 피드백**
   - 발표 후 질의응답을 통해 2차 학습을 진행하며, 피드백을 주고받습니다.

---

## 스터디 내용

### 3.1 김민찬: 네트워크

#### **Application Layer**

1. **애플리케이션 계층의 역할**
   - 애플리케이션 계층은 네트워크를 통해 서비스를 제공하는 다양한 애플리케이션들이 상호작용할 수 있도록 합니다.  
     예를 들어, 사용자가 웹 브라우저를 통해 웹 페이지를 요청할 때, 애플리케이션 계층은 HTTP(HyperText Transfer Protocol) 프로토콜을 사용하여 서버에 요청을 보내고, 그에 따른 응답을 다시 웹 브라우저로 전달합니다.

2. **애플리케이션 계층의 주요 프로토콜**
   - **HTTP (HyperText Transfer Protocol)**: 웹 페이지를 요청하고 전달하는 데 사용됩니다. 사용자가 웹사이트를 방문하면 HTTP 프로토콜을 통해 웹 서버와 통신하여 웹 페이지를 로드합니다.
   - **DNS (Domain Name System)**: 도메인 이름을 IP 주소로 변환하는 데 사용됩니다. 예: `www.example.com` → 적절한 IP 주소로 변환하여 웹 서버와 연결합니다.

#### **Application Layer 질문**

- **Q1**: 애플리케이션 계층과 전송 계층의 차이점은 무엇인가요?  
  **A1**: 애플리케이션 계층은 사용자와 직접적으로 상호작용하는 네트워크 서비스와 프로토콜을 처리하며, 전송 계층은 데이터의 전송 신뢰성을 보장하고 데이터를 세그먼트화하여 전달하는 역할을 합니다. 즉, 애플리케이션 계층은 서비스 제공, 전송 계층은 데이터 전송의 신뢰성 보장을 담당합니다.

- **Q2**: HTTP와 HTTPS의 차이는 무엇인가요?  
  **A2**: HTTPS는 HTTP의 보안 버전으로, SSL/TLS 프로토콜을 사용하여 암호화된 통신을 제공합니다. HTTPS는 데이터의 보안을 강화하기 위해 사용됩니다.

---

### 3.2 임도균: AI 알고리즘

#### **AI Search Algorithms**

1. **BFS (너비 우선 탐색)**
   - 루트 노드의 모든 자식 노드를 탐색한 후 솔루션이 발견되지 않으면 다음 단계로 넘어가는 알고리즘.
   - **장점**: 최단 경로를 보장.  
   - **단점**: 단계가 내려갈수록 탐색 시간이 증가.

```python
# Pseudo Code
breadth_first_search():
    open ← [시작노드]
    closed ← []
    while open != [] do
        X ← open 리스트의 첫 요소
        if X == goal then return SUCCESS
        else:
            X의 자식 노드 생성
            X를 closed 리스트에 추가
            X의 자식노드가 이미 open이나 closed에 있다면 버린다.
            나머지 자식 노드들을 open의 맨 뒤(밑)에 추가 (queue)
    return FAIL
```

2. **Hill Climbing Search(언덕 등반 탐색)**
   -현재 노드의 솔루션 중에서 가장 좋은 값이 현재 자신의 솔루션보다  좋으면 이동하는 알고리즘이다.
   - **장점**: 메모리 사용량이 효율적이며 비교적 작고 단순한 문제에서도 효율적으로 작동한다.
   - **단점**: 지역 최적해 위험, 고립된 상태 문제, 초기 상태 의존성 등의 문제가 있다.
   
```python
# Pseudo code

best_first_search():

open ← [시작노드]
closed ← []
while open != [] do
    X ← open 리스트에서 평가 함수 값이 제일 좋은 요소
    if X == goal then return SUCCESS
    else
        X의 자식 노드 생성
        X를 closed 리스트에 추가
        if X의 자식노드가 이미 open이나 closed에 있지 않다면,
            자식 노드의 평가 함수 h(n)의 값을 계산
            자식 노드들을 open 리스트에 추가
return FAIL
```

3. ** Best First Search(최고 우선 탐색)**
   -이 기법은 Hill-Climbing 기법을 약간 개선한 것으로 평가 함수와 open/closed 리스트를 사용하여 저장된 노드 중 평가 함수 값이 가장 좋은 노드를 선택하는 알고리즘이다.

```python
# Pseudo code

best_first_search()

open ← [시작노드]
closed ← []
while open != [] do
    X ← open 리스트에서 평가 함수 값이 제일 좋은 요소
    if X == goal then return SUCCESS
  else
        X의 자식 노드 생성
        X를 closed 리스트에 추가
        if X의 자식노드가 이미 open이나 closed에 있지 않다면,
            자식 노드의 평가 함수 h(n)의 값을 계산
            자식 노드들을 open 리스트에 추가
return FAIL

```
#### **AI Search Algorithms 질문**
**Q1**:검색 알고리즘(Search Algorithm)이란 무엇인가요?
**A1**:검색 알고리즘은 주어진 상태 공간(State Space)에서 목표 상태(Goal State)를 찾기 위한 절차를 말합니다. 이는 문제를 해결하기 위해 가능한 모든 해를 탐색하거나, 효율적인 탐색 방법을 활용하여 최적의 해를 찾는 과정을 포함합니다. 검색 알고리즘은 크게 **맹목적 탐색(Blind Search) **과 **경험적 탐색(Heuristic Search)**으로 나눌 수 있습니다.

**Q2**:맹목적 탐색과 경험적 탐색의 차이점은 무엇인가요?
**A2**:맹목적 탐색은 문제에 대한 사전 지식 없이도 가능한 솔루션의 모든 경로를 탐색하지만 경험적 탐색은 각 문제의 특성에 적절한 경험적 함수를 사용하여 탐색합니다. 따라서 두 탐색의 차이점은 탐색 방법에 효율성에서 차이가 나며 맹목적 탐색은 그저 해를 찾는게 목표라면 경험적 탐색은 효율적으로 해를 찾는게 목표라고 할 수 있습니다.

---

### 3.3 전동훈: 알고리즘

#### **그리디 알고리즘 (Greedy Algorithm)**

1. **개요**  
   그리디 알고리즘은 문제를 해결하는 과정에서 현재 시점에서 가장 최적이라고 판단되는 선택을 반복적으로 수행하여 최종적인 해결책을 찾는 알고리즘입니다. 이 알고리즘은 모든 선택이 최적이라는 전제하에 작동하며, 최적해를 보장하기 위해 문제는 그리디 알고리즘이 적용 가능한 **탐욕적 선택 속성(Greedy Choice Property)**과 **최적 부분 구조(Optimal Substructure)**를 가져야 합니다.

2. **특징**  
   - **탐욕적 선택**: 매 단계에서 가장 좋은 선택을 반복적으로 수행.
   - **최적 부분 구조**: 문제의 최적 해결 방법이 부분 문제의 최적 해결 방법으로 구성될 수 있음.
   - **효율성**: 탐색 공간을 줄이므로, 많은 경우 다른 알고리즘보다 빠르고 간단.
   - **제한사항**: 항상 전역 최적해를 보장하지 않음. 문제의 속성에 따라 잘못된 결과를 도출할 수도 있음.

3. **동작 방식**  
   - 문제를 분할: 문제를 여러 작은 부분 문제로 나눈다.
   - 탐욕적 선택: 현재 상황에서 가장 좋은 선택을 한다.
   - 문제 축소: 선택 결과를 기반으로 문제의 크기를 줄인다.
   - 반복: 더 이상 선택할 것이 없을 때까지 반복.

4. **시간 및 공간 복잡도**  
   - **시간 복잡도**: 문제에 따라 다르지만, 일반적으로 정렬이나 우선순위 큐를 사용하는 경우 O(n log n).
   - **공간 복잡도**: 보통 O(1) 또는 O(n).

5. **활용 사례**  
   - 최소 신장 트리 (MST): Kruskal, Prim 알고리즘.
   - 최단 경로 문제: 다익스트라 알고리즘.
   - 배낭 문제 (Knapsack Problem): Fractional Knapsack (분할 가능 배낭 문제).
   - 활동 선택 문제 (Activity Selection Problem).
   - 허프만 코딩 (Huffman Coding): 데이터 압축을 위해 빈도가 높은 문자를 최소 길이의 코드로 표현.

6. **코드 예제: 거스름돈 문제 (Python)**  
   문제: 주어진 동전 단위를 사용해 특정 금액을 최소 개수의 동전으로 구성.

```python
def greedy_change(coins, amount):
    coins.sort(reverse=True)  # 동전 단위를 내림차순 정렬
    result = {}

    for coin in coins:
        count = amount // coin  # 해당 동전으로 가능한 최대 개수
        if count > 0:
            result[coin] = count
            amount -= coin * count  # 잔액 갱신

    if amount > 0:
        print("거스름돈을 정확히 만들 수 없습니다.")
    return result

# Example
coins = [500, 100, 50, 10]
amount = 1260
print(greedy_change(coins, amount))
# Output: {500: 2, 100: 2, 50: 1, 10: 1}
```
7. **한계와 주의점**
   -**국소 최적화**

---
### 재귀 알고리즘

1. **개요**  
   재귀 알고리즘은 문제를 작은 문제로 분할하여 해결하는 알고리즘으로, 함수가 자기 자신을 호출하여 반복적으로 동작합니다. 재귀는 간단한 문제 해결 방식이지만, 적절한 종료 조건(base condition)을 설정하지 않으면 무한 루프에 빠질 수 있습니다.

2. **특징**  
   - **코드 간결성**: 반복문 대신 재귀를 사용해 간결한 코드 작성이 가능.
   - **종료 조건 필요**: 문제의 종료 조건이 반드시 정의되어야 함.
   - **시간 복잡도**: 문제에 따라 다르지만, 재귀 호출의 깊이에 따라 증가.
   - **공간 복잡도**: 호출 스택 사용으로 인해 O(n)의 공간을 차지.

3. **알고리즘의 동작 방식**  
   - 문제를 작게 나누어 자기 자신을 호출하며 해결한다.
   - 가장 작은 단위까지 나누었을 때, 종료 조건에 따라 연산을 종료한다.
   - 결과를 반환하며 원래 문제를 해결한다.

4. **활용 사례**  
   - 수학적 문제: 팩토리얼 계산, 피보나치 수열, 거듭제곱 계산 등.
   - 그래프 탐색: DFS와 같은 탐색 문제.
   - 분할 정복 알고리즘: 퀵 정렬, 병합 정렬.

5. **코드 예제**
   ```python
   def factorial(n):
    if n == 1:  # 종료 조건
        return 1
    return n * factorial(n - 1)  # 자기 자신 호출


     

---

### 백트래킹 알고리즘

1. **개요**  
   백트래킹(Backtracking)은 모든 가능한 조합을 탐색하면서, 유효하지 않은 경로는 더 이상 탐색하지 않고 되돌아가는 방식으로 최적해를 찾는 알고리즘입니다.

2. **특징**  
   - **탐색 방식**: DFS 기반으로 동작하며, 조건에 따라 가지를 쳐내며 탐색.
   - **효율성**: 가지치기(Pruning)를 통해 탐색 시간을 줄임.
   - **시간 복잡도**: 경우에 따라 달라지며, 일반적으로 O(2^n) 이상의 복잡도를 가짐.

3. **알고리즘의 동작 방식**  
   - 문제를 하나씩 해결하며, 조건에 따라 유효성을 판단.
   - 조건을 만족하지 않으면 이전 단계로 되돌아가 다음 경우를 탐색.
   - 모든 경우의 수를 탐색한 후 결과를 반환.

4. **활용 사례**  
   - **조합 및 순열 문제**: N-Queens 문제, Sudoku 해결.
   - **그래프 문제**: Hamiltonian Circuit, Knight's Tour 문제.
   - **최적화 문제**: 부분합 문제, 배낭 문제(Knapsack Problem).

5. **코드 예제**
```python
def solve_n_queens(n): 
result = [] 
board = [-1] * n # -1로 초기화 
def is_safe(row, col): 
for i in range(row): 
if board[i] == col or abs(board[i] - col) ==abs(i - row): 
return False 
return True 
def place_queen(row):
 	if row == n: 
result.append(board[:]) 
return 
for col in range(n): 
if is_safe(row, col): 
board[row] = col 
place_queen(row + 1)
 			board[row] = -1 # 백트래킹 
place_queen(0)
return result
```

---

### 각 알고리즘에 대한 질문

#### Q1: 그리디 알고리즘은 항상 최적의 해를 보장하나요?  
**A1**:  
아니요, 그리디 알고리즘은 모든 경우에 최적의 해를 보장하지 않습니다. 그리디 알고리즘이 최적의 해를 보장하려면 문제는 반드시 탐욕적 선택 속성(Greedy Choice Property)과 최적 부분 구조(Optimal Substructure)를 가져야 합니다.  
- **탐욕적 선택 속성**: 현재 단계에서의 최선의 선택이 전체 문제의 최적해로 이어지는 성질.  
- **최적 부분 구조**: 부분 문제의 최적해가 전체 문제의 최적해로 통합될 수 있는 성질.  

이 두 속성이 없는 경우, 그리디 알고리즘은 근사값만 제공하거나 아예 잘못된 해를 도출할 수도 있습니다.

#### Q2: 재귀 알고리즘은 왜 종료 조건이 꼭 필요하고, 종료 조건을 잘못 설정하면 어떤 일이 발생하나요?  
**A2**:  
재귀 알고리즘은 종료 조건 없이 계속해서 자기 자신을 호출하게 되면 **무한 재귀 호출**에 빠지게 됩니다. 이는 프로그램이 메모리 스택을 초과하여 **스택 오버플로(Stack Overflow)**를 발생시켜 프로그램이 비정상적으로 종료되는 원인이 됩니다.  
따라서, 재귀 알고리즘을 설계할 때는 반드시 종료 조건을 명확히 설정해야 하며, 이 조건이 문제가 끝났음을 올바르게 판단할 수 있도록 설계해야 합니다.

#### Q3: 백트래킹 알고리즘이 항상 최적해를 보장하나요?  
**A3**:  
백트래킹 알고리즘이 항상 최적해를 보장하는 것은 아닙니다. 백트래킹은 모든 가능한 경로를 탐색하면서 조건에 맞지 않는 경로를 가지치기(Pruning)하여 효율성을 높이는 방식으로 작동하지만, **최적해를 보장하려면 문제 자체가 특정 조건을 충족해야 합니다**.  
예를 들어, 백트래킹이 최적해를 찾기 위해서는 다음 조건들이 필요합니다:  
1. **경로마다 유효성을 검사하는 함수**가 정확히 정의되어야 함.  
2. **모든 가능한 경로를 탐색**할 수 있어야 함.  

그러나 경우에 따라 백트래킹 알고리즘은 최적해가 아닌 단순히 가능한 해만을 반환할 수 있습니다. 이러한 경우, **다이나믹 프로그래밍**이나 다른 최적화 기법을 병행해야 할 수도 있습니다.

### 3.4 이영민: iOS

#### **SwiftUI의 기본적 구조와 선언 방식**

1. **SwiftUI의 기본 단위**  
   SwiftUI는 제일 기본 단위인 **View**로 화면이 구성되며, 이 View는 구조체로 형성됩니다.  
   - 선언 예시: `struct 변수명 : View`  
     이 뷰 안에는 여러 가지 또 다른 구조체가 존재할 수 있습니다.

2. **구조체 요소의 선언 방식**  
   - 구조체 안에서 다른 요소를 선언할 때는 `var 변수명 : some View`라고 선언할 수 있습니다.
   - `some View`는 구조체의 요소로서 **View가 아닌 것이 View처럼 행동한다**는 의미로 사용됩니다.

---

#### **View Builder의 모습과 기능**

1. **View Builder 정의**  
   - 뷰 빌더는 뷰처럼 작동하는 것들을 튜플로 묶어 하나로 가지는 것을 의미합니다.
   - 선언 방식: `HStack`, `VStack`, `ZStack`, `LazyVGrid` 등으로 뷰들의 집합을 선언할 수 있습니다.

2. **동작 방식**  
   - `HStack`: 여러 뷰들을 가로 방향으로 연속적으로 나타냄.
   - `VStack`: 여러 뷰들을 위아래 세로 방향으로 연속적으로 나타냄.
   - 이처럼 다양한 방식으로 튜플형 뷰 집합을 구성할 수 있습니다.

---

#### **View 수정자와 선언 방식**

1. **View Modifier (뷰 수정자)**  
   - 선언된 뷰를 수정하기 위해 사용됩니다.
   - 뷰 뒤에 `.수정자명`으로 선언하여 동작합니다.  

     **예시**:  
     ```swift
     card.foregroundColor(.red)
     ```  
     위의 선언은 `card`라는 뷰처럼 작동하는 구조체에 `.foregroundColor(.red)` 수정자를 적용하여, `card` 뷰의 전면 색상을 빨간색으로 입힙니다.

---

#### **Views are Immutable and Locals in @ViewBuilder**

1. **뷰는 불변(Immutable)**  
   - 뷰 안에서 선언된 값들은 기본적으로 변경될 수 없는 변수입니다.

2. **@State를 사용한 상태 저장 및 변경**  
   - `@State`를 사용하면 변수의 상태를 저장하고 수정할 수 있는 임시 저장소를 생성합니다.  
   - 이를 통해 뷰 내부에서 수정이 가능하게 만듭니다.  

     **예시**:  
     ```swift
     @State var isFaceUp: Bool
     ```  
     위 선언을 통해 `isFaceUp` 변수는 뷰 내부에서 수정이 가능하게 됩니다.

---

### 스터디 진행 결과

- **김민찬**: 네트워크 애플리케이션 계층 학습을 통해 HTTP/HTTPS의 차이를 명확히 이해하고, 팀원들과 사례를 통해 응용 방안을 논의.
- **임도균**: BFS, Hill Climbing 등의 AI 탐색 알고리즘을 팀원들에게 설명하며, Pseudo Code 기반으로 원리를 이해.
- **전동훈**: 여러 알고리즘의 장단점을 발표하며, 팀원들과 코드 최적화 논의.
- **이영민**: SwiftUI 구조와 View Builder 활용을 팀원들에게 시연하며, iOS 개발의 기본 개념을 학습.

---

#### **성과 및 주요 인사이트**

1. **다양한 분야의 지식 폭을 넓히고 관심사를 확장**  
   - 스터디를 통해 알고리즘, 네트워크, iOS와 같은 다양한 주제를 다루며, 기존에 익숙하지 않았던 분야에 대한 이해를 높임.
   - 각 팀원이 서로 다른 관심사를 기반으로 발표를 진행하며, 새로운 시각을 접하고 더 넓은 관심사를 탐구하는 계기를 제공.

2. **발표와 질의응답을 통한 2차 학습 효과**  
   - 자신이 학습한 내용을 팀원들에게 발표하며 체계적으로 정리하는 과정을 거쳐 학습 효과를 높임.
   - 발표 후 질의응답 과정을 통해 부족한 부분을 보완하며, 단순히 배우는 것을 넘어 문제를 깊이 이해하고 응용하는 2차 학습 효과를 경험.

---

### 향후 계획

1. **구체적인 학습 목표**
   - **김민찬**: 네트워크 지식을 활용한 프로젝트 수행.
   - **임도균**: 다양한 AI 알고리즘에 대해 학습하고 직접 코드를 작성.
   - **전동훈**: 여러 정렬 알고리즘 정리 및 정적 프로그래밍 문제 풀이.
   - **이영민**: 유튜브 CS193p 강의를 통한 SwiftUI 심화 학습.



   
